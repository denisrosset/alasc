package net.alasc
package bsgs

trait BSGSBase[F <: FiniteElement[F], E <: PermElement[E]] {
  self: Group[F, E]#BSGSGroup =>

  def insertBasePoint(basePoint: Dom): Group[F, E]#BSGSGroup = this match {
    case terminal: BSGSGroupTerminal => new BSGSGroupNode(transversal.builder.empty(basePoint, representedIdentity),
      Nil, representedIdentity, isImmutable, this)
    case node: BSGSGroupNode => {
      require_(!base.list.contains(basePoint))
      val orbit = OrbitSet.fromSet(basePoint, strongGeneratingSet)
      if (orbit.size > 1)
        new BSGSGroupNode(node.trv, node.sg, node.id, node.isImmutable, tail.insertBasePoint(basePoint))
      else
        new BSGSGroupNode(transversal.builder.empty(basePoint, representedIdentity),
          strongGeneratingSet, representedIdentity, isImmutable, this)
    }
  }

  def withBase(newBase: Base): BSGSGroup = ???

  def withRedundantBasePoint(newBasePoint: Dom): BSGSGroup = this match {
    case g: BSGSGroupTerminal[E] => new BSGSGroupNode(transversal.builder.empty(newBasePoint, g.id), Nil, g.id, isImmutable, this)
    case g: BSGSGroupNode[E] => {
      require_(beta != newBasePoint)
      tail.withRedundantBasePoint(newBasePoint)
    }
  }

  def cleanedBase: BSGSGroup[E] = this match {
    case g: BSGSGroupTerminal[E] => g
    case g: BSGSGroupNode[E] => {
      if (g.trv.size == 1)
        g.tail.cleanedBase
      else
        new BSGSGroupNode(g.trv, g.sg, g.id, g.tail.cleanedBase)
    }
  }

  def conjugatedBy(e: E): BSGSGroup[E] = this match {
    case g: BSGSGroupTerminal[E] => g
    case g: BSGSGroupNode[E] =>  {
      val einv = e.inverse
      new BSGSGroupNode(g.trv.conjugatedBy(e), g.sg.map(x => einv*x*e), g.id, g.isImmutable, g.tl.conjugatedBy(e))
    }
  }

}
