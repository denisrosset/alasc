  /*





   def conjugatedBy(f: F): Group[F] = {
   val finv = f.inverse
   new Group(faithfulAction, identity,
   knownGenerators.map( _.map( g => finv * g * f ) ),
   None, // knownBaseForStrongGeneratorsAndAction.map( base => base.conjugatedBy(actionElement(f)) ),
   knownOrder,
   knownRandom.map( fun => ( (r: Random) => finv * fun(r) * f ) ),
   knownRandomIsUniformStateless,
   randomGenerator,
   transBuilder,
   baseStrategy)
   }

   def throwIncomplete = throw new IllegalArgumentException("Group information is incomplete. Lookup the Group class documentation for possible combinations.")

   def actionElement(f: F) = ActionElement(f, faithfulAction)

   def randomFromGeneratorsOnly = knownRandom match {
   case Some(rfun) => rfun
   case None => {
   require_(randomGenerator.isDefined)
   val gens = identity :: knownGenerators.getOrElse(throwIncomplete)
   val bag = RandomBag(gens, identity, max(10, gens.length), 50, randomGenerator.get)
   val rfun = (gen: Random) => bag.randomElement(gen)
   knownRandom = Some(rfun)
   knownRandomIsUniformStateless = false
   rfun
   }
   }

   def madeCompatible(that: Group[F]) = {
   assert(that.faithfulAction == faithfulAction)
   assert(bsgs.base == that.bsgs.base)
   that
   }
   */
   /*
   def isSubgroup(potentialSubgroup: Group[F]) =
   this.intersection(potentialSubgroup).order == potentialSubgroup.order

   FIXME: restore this
   def intersection(that: Group[F]) = {
   val newBSGS = bsgs.intersection(madeCompatible(that).bsgs)
   new Group(faithfulAction, 
   identity,
   knownBSGS = Some(newBSGS),
   randomGenerator = if (randomGenerator == that.randomGenerator) randomGenerator else None)
   }
   def &(that: Group[F]) = intersection(that)
   */

   /*
   override def toString = (knownGenerators match {
   case Some(s) => "Group " + s.mkString("<", ", ", ">")
   case None => "Unconstructed group"
   }) + (knownOrder match {
   case Some(o) => " of order " + o
   case None => ""
   })

   def elements = bsgs.elements.map(_.represents.source)
   def compatible(f: F) = true
   def contains(f: F) = bsgs.contains(actionElement(f))
   */
   }

   object Group {
   /*
   def apply[F <: FiniteElement[F] : ClassTag](faithfulAction: Action[F, Perm], gens: Iterable[F], identity: F)(implicit gen: Random) = {
   require_(!gens.isEmpty) // TODO: relax and allow trivial group
   val id = if (identity eq null) gens.head*gens.head.inverse else identity
   val g = new Group(faithfulAction, id, knownGenerators = Some(gens.toList))
   g
   }
   def apply[P <: PermElement[P] : ClassTag](gens: Iterable[P], identity: P) = {
   require_(!gens.isEmpty) // TODO: relax and allow trivial group
   val id = if (identity eq null) gens.head*gens.head.inverse else identity
   val g = new Group(PermConversionAction, id, knownGenerators = Some(gens.toList))
   g
   }
   def apply[F <: FiniteElement[F] : ClassTag](faithfulAction: Action[F, Perm], rand: Random => F, order: BigInt, identity: F)(implicit gen: Random) = {
   val id = if (identity eq null) { val e = rand(gen); e*e.inverse } else identity
   val g = new Group(faithfulAction, id, knownRandom = Some(rand), knownOrder = Some(order))
   g
   }
   def apply[P <: PermElement[P] : ClassTag](rand: Random => P, order: BigInt, identity: P)(implicit gen: Random) = {
   val id = if (identity eq null) { val e = rand(gen); e*e.inverse } else identity
   val g = new Group(PermConversionAction, id, knownRandom = Some(rand), knownOrder = Some(order))
   g
   }
   def symmetricGroup(degree: Int) = {
   val gens = (1 until degree).map(i => Perm(degree)(Dom._1(i), Dom._1(i+1)))
   Group(gens, Perm(degree))
   }
   */
   }
