package net.alasc.blackbox

import scala.annotation.tailrec
import scala.collection.mutable.ArrayBuffer
import scala.reflect.ClassTag

import spire.algebra.{Eq, Group}
import spire.syntax.cfor._
import spire.syntax.eq._
import spire.syntax.group._

/** Implementation of Dimino's algorithm to generate group elements. */
object Dimino {

  /** Generates the elements of the group according to the Simple Dimino's Algorithm,
    * see page 20 of G. Butler, "Fundamental Algorithms for Permutation Groups", Springer 1991
    *
    * @param s  Sequence containing the group generators
    * @return   An array containing the group elements
    */
  def apply[G:ClassTag:Eq:Group](s: IndexedSeq[G]): Array[G] = {
    // treat the special case <s1>
    val elements = ArrayBuffer(Group[G].id)

    var g = s(0)
    while (!g.isId) {
      elements += g
      g = g |+| s(0)
    }

    // run the induction step starting at s(1)
    runInduction(elements, s, 1)

    elements.toArray
  }


  /** Subroutine that runs the induction step on the elements stored in the Buffer `elements`.
    *
    * @param elements Buffer already containing the elements of the group generated by s(0) ... s(start - 1)
    * @param s        Generators of the group to be constructed
    * @param start    Index from which to start the induction process
    */
  def runInduction[G:Eq:Group](elements: ArrayBuffer[G], s: IndexedSeq[G], start: Int): Unit = {
    @inline def order: Int = elements.length
    @tailrec @inline def contained(el: G, j: Int, n: Int): Boolean =
      if (j >= n) false
      else if (elements(j) === el) true
      else contained(el, j + 1, n)

    // treat inductive levels from `start`
    cforRange(start until s.length) { i =>
      if (!contained(s(i), 0, elements.length)) { // next generator is not redundant
      val previousOrder = order // i.e. |H_{i-1}|
        // first useful coset representative is s_i --- add a coset
        elements += s(i)
        cforRange(1 until previousOrder) { j =>
          elements += elements(j) |+| s(i)
        }

        // get coset representative's position
        var repPos = previousOrder
        do {
          cforRange(0 to i) { k =>
            val elt = elements(repPos) |+| s(k)
            if (!contained(elt, 0, elements.length)) { // add coset
              elements += elt
              cforRange(1 until previousOrder) { j =>
                elements += elements(j) |+| elt
              }
            }
          }
          repPos += previousOrder
        } while (repPos < order)
      } // not s_i in elements
    } // i = 2, ...
  }

}
