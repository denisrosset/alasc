package net.alasc.algebra

import scala.annotation.tailrec
import scala.reflect.{ClassTag, classTag}

import spire.algebra.PartialOrder
import spire.algebra.lattice.{BoundedJoinSemilattice, Lattice}
import spire.syntax.lattice._
import spire.util.Opt

import net.alasc.syntax.permutationAction._

/** Describes a family of permutation representations of a group G. Depending on the particular subgroup H of G,
  * the permutation representation can differ: thus, one obtains a representation valid for a set of generators
  * by calling `representation`.
  *
  * Given representations a and b, one defines a joined representation c such that if A and B are subgroups
  * of G for which a and b are valid, the representation c is valid for the union of A and B. This is described
  * using a join-semilattice.
  * 
  * Methods are generic in their arguments (i.e. they accept a `Representation[G]`), and return a representation
  * specific to the current class.
  */ 
trait Representations[G] { self =>
  // Members to implement

  /** Own representation type. */
  type R <: Representation[G]
  /** And its class tag. */
  val RClassTag: ClassTag[R]

  def get(generators: Iterable[G]): R

  /** Lattice of representations. */
  implicit def lattice: Lattice[R] with BoundedJoinSemilattice[R]
  implicit def partialOrder: PartialOrder[R]

  trait RCastTrait {
    def unapply(r: Representation[G]): Opt[R] = r match {
      case RClassTag(typed) if typed.representations eq self => Opt(typed)
      case _ => Opt.empty[R]
    }
  }

  /** Extraction of a specialized representation. */
  val RCast: RCastTrait = new RCastTrait { }

  // Members with default implementation

  /** If `r` is a representation of the correct type, returns `r`, or creates a new representation from
    * `generators`.
    */ 
  def get(genR: Representation[G], generators: Iterable[G]): R = genR match {
    case RCast(r) => r
    case _ => get(generators)
  }

  /** Returns a representation that is compatible with the union of subgroups generated by `generators1` and
    * `generators2`. Representations `r1` and `r2` are provided, and will be used in the join provided they
    * are of the type of the representations described by this object.
    */
  def repJoin(r1: Representation[G], r2: Representation[G],
    generators1: Iterable[G], generators2: Iterable[G]): R =
    r1 match {
      case RCast(rep1) => r2 match {
        case RCast(rep2) =>
          if (rep1 eq rep2) rep1 else (rep1 join rep2)
        case _ =>
          if (generators2.forall(rep1.represents(_)))
            rep1
          else
            (rep1 join get(generators2))
      }
      case _ => r2 match {
        case RCast(rep2) =>
          if (generators1.forall(rep2.represents(_)))
            rep2
          else
            (get(generators1) join rep2)
        case _ => get(generators1 ++ generators2)
      }
    }

  /** Returns a representation that is compatible with the union of subgroups generated by `generators1` and
    * `generators2`. The representations `r1` is provided for the first subgroup, and will be used in the join
    * provided it is of the type of the representations described by this object.
    */
  def repJoin(r1: Representation[G], generators1: Iterable[G], generators2: Iterable[G]): R =
    r1 match {
      case RCast(rep1) => rep1 join get(generators2)
      case _ => get(generators1 ++ generators2)
    }

  /** Returns a representation that is compatible with the intersection of subgroups generated by `generators1` and
    * `generators2`. Representations `r1` and `r2` are provided, and will be used in the join provided they
    * are of the type of the representations described by this object.
    */
  def repMeet(r1: Representation[G], r2: Representation[G],
    generators1: Iterable[G], generators2: Iterable[G]): R =
    RCast.unapply(r1).getOrElse(get(generators1)) meet RCast.unapply(r2).getOrElse(get(generators2))
}

object Representations {
  @inline final def apply[G](implicit ev: Representations[G]): Representations[G] = ev
}

/** Implementation of representations for genuine permutation types such as `Perm` or `Cycles`. */
final class PermutationRepresentations[P](implicit ev: Permutation[P]) extends Representations[P] {
  self =>
  def forSize(size: Int): Representation[P] = R(size)
  val RClassTag = classTag[R]
  case class R(size: Int) extends Representation[P] {
    def action = ev
    val representations = self
    def represents(p: P) = p.supportMax.getOrElseFast(-1) < size
  }
  def get(generators: Iterable[P]) = {
    @tailrec def rec(size: Int, iterator: Iterator[P]): Int =
      if (iterator.hasNext)
        rec(size.max(iterator.next.supportMax.getOrElseFast(-1) + 1), iterator)
      else size
    R(rec(1, generators.iterator))
  }
  /** Permutation representations are unique. */
  override val RCast = new RCastTrait {
    override def unapply(r: Representation[P]): Opt[R] = r match {
      case typed: R if typed.representations.isInstanceOf[PermutationRepresentations[_]] => Opt(typed)
      case _ => Opt.empty[R]
    }
  }
  implicit object partialOrder extends PartialOrder[R] {
    def partialCompare(x: R, y: R) = (x.size - y.size).signum.toDouble
  }
  implicit object lattice extends Lattice[R] with BoundedJoinSemilattice[R] {
    def zero = R(2)
    def join(x: R, y: R) = if (x.size >= y.size) x else y
    def meet(x: R, y: R) = if (x.size <= y.size) x else y
  }
}

object PermutationRepresentations {
  @inline final def apply[G](implicit ev: PermutationRepresentations[G]): PermutationRepresentations[G] = ev
}
